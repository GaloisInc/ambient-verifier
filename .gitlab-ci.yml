variables:
  DOCKER_TAG: "nightly"

stages:
  - build-and-test
  - docker-cleanup

# SSH setup, needed to clone private submodules. This template was taken from
# https://docs.gitlab.com/ee/ci/ssh_keys/
.ssh-setup-script: &ssh-setup-script
  ##
  ## Run ssh-agent (inside the build environment)
  ##
  - eval $(ssh-agent -s)
  ##
  ## Add the SSH key stored in SSH_PRIVATE_KEY variable to the agent store
  ## We're using tr to fix line endings which makes ed25519 keys work
  ## without extra base64 encoding.
  ## https://gitlab.com/gitlab-examples/ssh-private-key/issues/1#note_48526556
  ##
  - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
  ##
  ## Create the SSH directory and give it the right permissions
  ##
  - mkdir -p ~/.ssh
  - chmod 700 ~/.ssh
  ##
  ## Use ssh-keyscan to scan the keys of your private server.
  ##
  - ssh-keyscan gitlab-ext.galois.com >> ~/.ssh/known_hosts
  - chmod 644 ~/.ssh/known_hosts

# The default job that builds the verifier and runs the test suite. We run
# these on shared GitLab CI runners.
ambient-verifier:
  tags:
    - docker
  stage: build-and-test
  image: ubuntu:20.04
  cache:
    key: ${CI_JOB_NAME}-${GHCVER}
    paths:
      - dist-newstyle/
      # Ideally, we'd just cache /root/.cabal/store, but GitLab CI only allows
      # you to cache local items (according to a nugget of wisdom found in the
      # comments of https://docs.gitlab.com/ee/ci/caching/#cache-python-dependencies).
      # For this reason, we move the global /root/.cabal directory to the local
      # project directory after building so that GitLab CI will properly cache
      # it. Similarly, we move the local .cabal directory to /root/.cabal
      # after retrieving the cache (but before building) so that cabal can find
      # it properly.
      - .cabal/store
  before_script:
    - apt update
    - DEBIAN_FRONTEND=noninteractive apt install -y --no-install-recommends tzdata
    - apt install -y software-properties-common wget unzip openssh-client git zlib1g-dev curl build-essential libtinfo5 libgmp10 libgmp-dev locales sudo gcc
    - locale-gen en_US.UTF-8
    - update-locale LANG=en_US.UTF-8
    - export LANG=en_US.UTF-8
    - export LC_ALL=en_US.UTF-8
    - *ssh-setup-script
    - mkdir -p $HOME/.ghcup/bin
    - export PATH=$PWD/bin:$HOME/.ghcup/bin:$PATH
    - wget https://downloads.haskell.org/~ghcup/0.1.17.8/x86_64-linux-ghcup-0.1.17.8 -O $HOME/.ghcup/bin/ghcup
    - chmod +x $HOME/.ghcup/bin/ghcup
    - ghcup install cabal
    - git config --global url."https://github.com/".insteadOf "git@github.com:"
    - git config --global url."https://".insteadOf "git://"
    - git submodule update --init --depth 1
    - curl -sL https://github.com/RyanGlScott/submods-to-source-repos/releases/download/0.0.0.20211210/submods-to-source-repos-0.0.0.20211210.xz > submods-to-source-repos.xz
    - echo 'f339f4bbe43af96df7e8ce115377e56f4861bab5c8f66d3129492cbe7695bbac  submods-to-source-repos.xz' | sha256sum -c -
    - xz -d < submods-to-source-repos.xz > submods-to-source-repos
    - rm -f submods-to-source-repos.xz
    - chmod a+x submods-to-source-repos
  script:
    - RUNNER_OS=Linux SOLVER_PKG_VERSION="snapshot-20220131" BUILD_TARGET_OS="ubuntu-20.04" .gitlab-ci/solvers.sh install_system_deps
    - yices --version
    - ghcup install ghc --platform x86_64-deb8-linux $GHCVER --verbose
    - ./submods-to-source-repos cabal.project.dist > cabal.project
    - cat cabal.project
    - mv .cabal /root/.cabal || true
    - cabal update
    - cabal configure -w ghc-$GHCVER --enable-tests pkg:ambient-verifier
    - cabal build pkg:ambient-verifier
    - cabal test pkg:ambient-verifier
    - mv /root/.cabal .cabal || true
  parallel:
    matrix:
      - GHCVER: [8.10.7, 9.0.2, 9.2.3]
        CABALVER: [1]

# A job dedicated to building the Docker image and pushing it to Artifactory.
# This job requires a special CI runner so that it may have access to the
# `docker` command, which the shared GitLab runners do not have. This job is
# only run on the `master` branch.
artifactory-build:
  tags:
    - artifactory
  stage: build-and-test
  script:
    - *ssh-setup-script
    - git config --global url."https://github.com/".insteadOf "git@github.com:"
    - git config --global url."https://".insteadOf "git://"
    - git submodule update --init
    - docker login -u $CI_USERNAME -p $CI_PASSWORD $CI_REGISTRY
    - docker pull $CI_REGISTRY_IMAGE:latest || true
    - docker build --cache-from $CI_REGISTRY_IMAGE:latest --tag $CI_REGISTRY/$DOCKER_TAG .
    - docker push $CI_REGISTRY/$DOCKER_TAG || true
  rules:
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'

# Perform some last-minute Docker-related cleanup. This is in a separate stage
# because even if we cancel the artifactory-build stage, we still want to
# perform cleanup afterwards.
artifactory-cleanup:
  tags:
    - artifactory
  stage: docker-cleanup
  needs:
    - job: artifactory-build
      optional: true
  script:
    - docker rmi $CI_REGISTRY/$DOCKER_TAG || true
      # Even running `docker rmi` isn't enough to clear all of the files that
      # Docker builds up when building images. While the gitlab-runner
      # provides a clear-docker-cache script that should, in theory, fit this
      # need (see
      # https://docs.gitlab.com/runner/executors/docker.html#clearing-docker-cache),
      # in practice it doesn't appear to actually remove anything that
      # `docker rmi` doesn't already remove. To make absolute sure that Docker
      # isn't slowly eating up disk space after each build, we employ the
      # nuclear approach of running `docker system prune`. Since we rebuild the
      # entire Docker image on each run anyway, this is probably an acceptable
      # compromise to make.
    - docker system prune --force
    - docker logout $CI_REGISTRY
  rules:
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'
