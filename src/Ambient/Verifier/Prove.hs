{-# LANGUAGE GADTs #-}
{-# LANGUAGE ViewPatterns #-}
-- | Tools for proving goals generated by the verifier
module Ambient.Verifier.Prove (
  proveObligations
  ) where

import qualified Control.Concurrent as CC
import qualified Control.Concurrent.Async as CCA
import qualified Control.Concurrent.QSem as CCQ
import qualified Control.Exception as X
import           Control.Lens ( (^.) )
import           Control.Monad.IO.Class ( MonadIO, liftIO )
import qualified Data.IORef as IORef
import qualified Data.Time.Clock as DTC
import qualified GHC.Conc as GC
import qualified Lumberjack as LJ
import qualified What4.Expr as WE
import qualified What4.Interface as WI
import qualified What4.Solver as WS

import qualified Lang.Crucible.Backend as LCB

import qualified Ambient.Diagnostic as AD
import qualified Ambient.Timeout as AT

-- | Stream logs produced by the SMT solver connection out as diagnostics
--
-- Note that there should not be very many of these unless there is a major
-- system configuration issue
streamLogData
  :: LJ.LogAction IO AD.Diagnostic
  -> WS.LogData
streamLogData logAction =
  WS.LogData { WS.logVerbosity = 3
             , WS.logReason = "Solving Goals"
             , WS.logHandle = Nothing
             , WS.logCallbackVerbose = \level msg -> do
                 LJ.writeLog logAction (AD.SolverInteractionEvent level msg)
             }

-- | A tag to report when a solver thread has been canceled via a timeout
data Timeout = Timeout

-- | Prove a single goal in a separate thread (respecting the available capabilities)
--
-- This function manages mapping threads to capabilities in a scalable way while
-- also managing per-goal timeouts.
proveOneGoal
  :: ( LCB.IsSymInterface sym
     , sym ~ WE.ExprBuilder t st fs
     )
  => LJ.LogAction IO AD.Diagnostic
  -> sym
  -> WS.SolverAdapter st
  -- ^ The solver adapter to use to prove the goal
  -> IORef.IORef [CCA.Async ()]
  -- ^ The collection of pending worker threads
  -> CCQ.QSem
  -- ^ A count of available capabilities, which will block workers until
  -- capabilities become available to avoid swamping the system
  -> LCB.Assumptions sym
  -- ^ Assumptions in scope for this goal
  -> LCB.LabeledPred (WE.Expr t WI.BaseBoolType) msg1
  -- ^ The goal to prove
  -> AT.Timeout
  -- ^ The solver timeout for proving the goal
  -> IO ()
proveOneGoal logAction sym adapter workers sem assumptionsInScope p timeoutDuration = do
  -- We spawn a thread that waits until there is an available capability
  --
  -- That thread implements the timeout logic and invokes the solver under that timeout
  --
  -- The bracket ensures that the capability is always returned
  timeoutWrapper <- CCA.async (X.bracket_ (CCQ.waitQSem sem) (CCQ.signalQSem sem) spawnWorker)

  -- Save the handle to the outer thread so that we can wait on them all later
  --
  -- Using an IORef is safe here because the traversal of the Goals structure is
  -- serialized (only the solver executions are concurrent).
  IORef.modifyIORef' workers (timeoutWrapper:)
  where
    -- The actual worker races the solver thread against a timeout thread
    spawnWorker = do
      worker <- CCA.async $ do
        assumptions <- LCB.assumptionsPred sym assumptionsInScope
        goal <- WI.notPred sym (p ^. LCB.labeledPred)
        t0 <- DTC.getCurrentTime
        WS.solver_adapter_check_sat adapter sym (streamLogData logAction) [assumptions, goal] $ \satRes -> do
          t1 <- DTC.getCurrentTime
          case satRes of
            WS.Unsat {} -> LJ.writeLog logAction (AD.ProvedGoal sym p (t1 `DTC.diffUTCTime` t0))
            WS.Unknown -> LJ.writeLog logAction (AD.GoalTimeout sym p)
            WS.Sat _model -> LJ.writeLog logAction (AD.DisprovedGoal sym p (t1 `DTC.diffUTCTime` t0))
      timeout <- CCA.async $ do
        CC.threadDelay (AT.microsAsInt (AT.timeoutAsMicros timeoutDuration))
        CCA.cancel worker
        return Timeout

      -- Wait for the worker to finish, or cancel it after a timeout
      res <- CCA.waitEitherCatch worker timeout
      case res of
        Right (Right Timeout) ->
          LJ.writeLog logAction (AD.GoalTimeout sym p)
        Right (Left exn) ->
          LJ.writeLog logAction (AD.ErrorProvingGoal sym p exn)
        Left (Left exn) ->
          LJ.writeLog logAction (AD.ErrorProvingGoal sym p exn)
        Left (Right ()) -> return ()

-- | Prove all of the obligations generated during symbolic execution
--
-- This extracts the goals tree from the symbolic backend (@sym@) and traverses
-- the structure to prove each goal.
--
-- NOTE: This solves goals in parallel using an offline solver (i.e., the
-- 'WS.SolverAdapter'), which means that it spawns a fresh solver instance for
-- each goal.
proveObligations
  :: (LCB.IsSymInterface sym, sym ~ WE.ExprBuilder t st fs, MonadIO m)
  => LJ.LogAction IO AD.Diagnostic
  -> sym
  -> WS.SolverAdapter st
  -> AT.Timeout
  -> m ()
proveObligations logAction sym adapter timeoutDuration = do
  mobligations <- liftIO (LCB.getProofObligations sym)
  case mobligations of
    Nothing -> return ()
    Just obligations -> do
      workersRef <- liftIO $ IORef.newIORef []
      caps <- liftIO GC.getNumCapabilities
      sem <- liftIO (CCQ.newQSem caps)

      -- Traverse the proof obligations and spawn off threads to attempt to prove them
      go workersRef sem mempty obligations

      -- Block until all of the workers finish (possibly by timing out)
      workers <- liftIO $ IORef.readIORef workersRef
      liftIO $ mapM_ CCA.wait workers
  where
    go workers sem assumptionsInScope goals =
      case goals of
        LCB.Assuming asumps childGoals ->
          go workers sem (asumps <> assumptionsInScope) childGoals
        LCB.ProveConj children1 children2 -> do
          go workers sem assumptionsInScope children1
          go workers sem assumptionsInScope children2
        LCB.Prove p -> liftIO $ proveOneGoal logAction sym adapter workers sem assumptionsInScope p timeoutDuration
